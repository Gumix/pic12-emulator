# Описание общих требований к написанию функций и тестов для эмулятора.

Это необходимо, т.к. основа эмулятора уже написана, поэтому для того, чтобы он работал как нужно и примерно одинаково для всех функций, эти функции должны быть описаны определённым образом.

## Для начала - структура эмулятора и основные переменные.

Это биты в регистре флагов (статусов) поимённо. Они нам будут нужны, когда нужно протестировать функцию и убедиться, что она никакие из флагов не поменяла, какие не должна была.
```
#define STATUS_C			0
#define STATUS_DC			1
#define STATUS_Z			2  -> это флаг нулевого результата; если он установлен,
								  значит результат последней операции = 0
#define STATUS_PD			3
#define STATUS_TO			4
#define STATUS_RP0			5  -> это флаг переключения между двумя частями памяти
								  зачем он нужен - описано ниже
```

Это список некоторых конкретных регистров из памяти. Соответственно, чтобы обратиться к одному из них: например, `mem[STATUS]` - обращение к регистру флагов. К остальным ячейкам памяти обращаемся просто как к элементам массива mem. Индекс массива - соответственно, адрес переменной.
```
#define TMR0				0x01
#define PCL					0x02
#define STATUS				0x03
#define FSR					0x04
#define GPIO				0x05
#define PCLATH				0x0A
#define INTCON				0x0B
#define PIR1				0x0C
#define TMR1L				0x0E
#define TMR1H				0x0F
#define T1CON				0x10
#define CMCON				0x19
#define OPTION_REG			0x81
#define TRISIO				0x85
#define PIE1				0x8C
#define PCON				0x8E
#define OSCCAL				0x90
#define WPU					0x95
#define IOC					0x96
#define VRCON				0x99
#define EEDATA				0x9A
#define EEADR				0x9B
#define EECON1				0x9C
```

### Основные функции:

```
#define BIT_GET(x, y)		(((x) >> (y)) & 1)
```
Возвращает 1 или 0 в зависимости от того, установлен в регистре x бит y или нет.
Например: `BIT_GET(*mem[STATUS], STATUS_Z)` возвращает 1, если флаг Z установлен.

```
#define BIT_SET(x, y)		((x) |= (1 << (y)))
```
Процедура, которая устанавливает в регистре x в бит y значение 1.
Например, у нас функция обнуляет регистр W и мы хотим установить в регистре флагов флаг нуля: `BIT_SET(*mem[STATUS], STATUS_Z)`.

```
#define BIT_CLEAR(x, y)		((x) &= ~(1 << (y)))
```
Процедура, которая очищает бит y в регистре x, если он был установлен.
Например, предыдущий пример наоборот - нам надо, чтобы флаг нуля не был установлен: `BIT_CLEAR(*mem[STATUS], STATUS_Z)`.

```
#define REGISTER(x, y)		(*x[(BIT_GET(*mem[STATUS], STATUS_RP0) ? y+UNREAl_OFFSET : y)])
```
Функция, обращающаяся к регистру по адресу y. X обычно используется - либо массив mem, либо при тестировании массив smem (сохранённая память для тестов).

Обращение по разным адресам в функции - по адресу y или по адресу y + спец. смещение происходит из-за того, что на самом деле память микроконтроллера состоит из двух частей. То, в какую память мы хотим обратиться сейчас, определяется установкой флага `STATUS_RP0` из регистра флагов. В принципе, можно с этим не заморачиваться в самих функциях. Это используется только в функции тестирования - для прохождения по всем возможным регистрам памяти.

### Основные глобальные переменные, которые должны использоваться во всех функциях и тестах и вспомогательных процедурах:

```
unsigned char W;						// Аккумулятор
int PC;									// Счётчик команд
short prog[PROG_MEM_SIZE];				// Сама программа
unsigned char real_mem[DATA_MEM_SIZE];	// Некая вспомогательная (исходная) память. Не используем!
unsigned char *mem[DATA_MEM_SIZE];		// Память!

unsigned char sW;						// Saved accumulator for tests
int sPC;								// Saved program counter for tests
unsigned char sreal_mem[DATA_MEM_SIZE];
unsigned char *smem[DATA_MEM_SIZE];		// Saved data memory for tests
```

## Далее переходим собственно к написанию процедур.

Пишете процедуру свою, используя вышеуказанные функции и переменные. Вставляете в место проги, где уже есть заготовка. При этом, обязательно обращайте внимание на те параметры, которые передаются в вашу функцию - их менять не рекомендуется :)

Кстати, по поводу параметров. Во время последней лабы была выявлена одна ошибка, которая встретилась у многих. Для функций, которые используют память и: увеличивают, уменьшают регистр f и т.п., f - это адрес того регистра, значение которого мы должны уменьшить. На деле же мы получаем, что значение f, которое передаётся в функцию - это индекс в массиве памяти. Это не регистр, это адрес регистра. Соответственно, чтобы обратиться к значению регистра, используем: `REGISTER(mem, f) = ...`.

После того, как вы написали свою функцию (желательно, предварительно её проверив просто в отдельной проге), пишем тест. Вообще, по-хорошему, мы должны сначала писать тест к той функции, какую изучаем, а после этого уже сам текст функции. Но я сейчас описываю, куда что вставлять, так что не важно, в каком порядке вы это будете делать :)

### Итак, тестирование:

Тест должен быть написан для каждой функции. Перед любым тестированием необходимо зафиксировать текущее состояние памяти. Для этого уже написана процедура:
```
void save_state()
{
	int i;

	sW = W;
	sPC = PC;
	
	for (i = 0; i < DATA_MEM_SIZE; i++)
		*smem[i] = *mem[i];
}
```

Проверять мы должны:

Изменился или нет счётчик PC. Для этого уже написана процедура:
```
void test_PC_was_increased()
{
	assert(PC == sPC + 1);
}
```

Если нужно проверить, что счётчик изменился не на 1, а на 2, то нужно написать свою функцию аналогичную или посмотреть, не написана ли она до вас.

Уже написаны процедуры тестов, что аккумулятор не изменился:
```
void test_accumulator_was_untouched()
{
	assert(W == sW);
}
```

Написана процедура теста, проверяющая установку флага Z в зависимости от состояния аккумулятора:
```
void test_zero_flag_set()
{
	if (W) assert(! BIT_GET(*mem[STATUS], STATUS_Z));
	else assert(BIT_GET(*mem[STATUS], STATUS_Z));
}
```

Кроме этих стандартных процедур проверки, каждый должен написать конкретно для своей функции проверку.

Если процедура должна изменять память, то проверяем:
- изменилась ли память там, где должна;
- не изменилась ли ВСЯ остальная память. Пример таких проверок уже есть - например, для функции INCFSZ. Замечание: как раз в этом тесте используется тот факт, что память двойная. Сначала мы снимаем флаг вспомогательной памяти `BIT_CLEAR(*mem[STATUS], STATUS_RP0)` проверяем, не изменилась ли эта часть памяти. Затем, устанавливаем флаг `BIT_SET(*mem[STATUS], STATUS_RP0)` и проверяем вторую часть памяти.

Если процедура должна изменять особенным образом счётчик команд, то пишем проверку о правильности этого изменения.

Если процедура изменяет флаги, то проверяем:
- изменился ли тот флаг, который нас интересует
- не изменились ли все остальные флаги. Пример такой проверки тоже уже есть - проверка для функции CLRW

Если процедура должна установить \ снять биты в определённом регистре, то проверяем:
- установился \ снялся нужный нам бит
- не изменились ли все остальные биты регистра

И т.д., если есть какие-то дополнительные проверки конкретно для вашей процедуры - дописываем их, указывая, к какой процедуре относится данный тест.

### Вроде основные моменты я указала. Итак, получаем: 
- нужно написать (переписать свои процедуры, если уже мне присылали) в соответствии с теми функциями \ параметрами \ переменными, которые определены в эмуляторе;
- нужно написать тест основной к своей процедуре и (если нужно) вспомогательные функции. Обращаю внимание на то, что многие функции похожи и тесты к ним, возможно, понадобятся абсолютно одинаковые. Поэтому не поленитесь - просмотрите список уже написанных, чтобы не дублировать. В своём тесте просто обращаемся к той или иной процедуре проверки. Все процедуры проверки должны работать по принципу - если не верно, то вылетаем из проги с ошибкой (assert).
- После этого дома (!) запускаете эмулятор и проверяете, что он не ломается, когда там появилась ваша процедурка :) Если ломается - исправляем. И кидаем мне не весь эмулятор, а конкретно вашу процедуру и ваши тесты. Я вставляю в общий эмулятор и радуюсь, что всё продолжает работать!

После того, как все-все-все процедурки и тесты будут написаны и вставлены в эмулятор, и он заработает, мы получим зачёт! :)

P.S. Для активистов: у нас по-прежнему есть ещё свободные функции, которые можно разбирать и дописывать. Это будет очень здорово!
